# Redis production configuration

# 1. Memory Management
# Max memory limit in bytes. When the memory limit is reached, Redis will start
# removing keys according to the configured policy.
maxmemory 256mb
# Policy for eviction when maxmemory is reached:
# volatile-lru -> Evict using approximated LRU among keys with an expire set.
# allkeys-lru -> Evict any key using approximated LRU.
# volatile-lfu -> Evict using approximated LFU among keys with an expire set.
# allkeys-lfu -> Evict any key using approximated LFU.
# volatile-random -> Evict random keys among keys with an expire set.
# allkeys-random -> Evict random keys.
# volatile-ttl -> Evict keys with an expire set, and try to evict keys with a shorter TTL first.
# noeviction -> Don't evict anything, just return errors on write operations.
maxmemory-policy allkeys-lru

# 2. Persistence Configuration
# Enable AOF (Append Only File) persistence for better data durability.
# Every command that modifies the dataset is logged to the AOF.
appendonly yes

# The fsync() call tells the operating system to actually write data on disk.
# appendfsync always: Slow, but safest.
# appendfsync everysec: Good compromise, fsync every second.
# appendfsync no: Fastest, but can lose up to a few seconds of data.
appendfsync everysec

# When AOF rewrite is in progress, don't fsync data on disk.
# This can improve performance during AOF rewrite, but may lead to data loss
# if Redis crashes during rewrite and the system also crashes.
no-appendfsync-on-rewrite no

# Automatic AOF rewrite trigger.
# When the AOF file size doubles (100%) and is at least 64mb, rewrite it.
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# RDB persistence (snapshots) - point-in-time backups.
# Save the dataset to disk:
# save <seconds> <changes>
#   - after 900 sec (15 min) if at least 1 key changed
#   - after 300 sec (5 min) if at least 10 keys changed
#   - after 60 sec (1 min) if at least 10000 keys changed
save 900 1
save 300 10
save 60 10000

# 3. Security Settings
# Require clients to authenticate with a password.
# IMPORTANT: Replace 'your_strong_password_here' with a strong, unique password.
# This should be loaded from an environment variable or secret management system in production.
requirepass ${REDIS_PASSWORD}

# Rename dangerous commands to prevent accidental or malicious use.
# For example, FLUSHALL can wipe your entire database.
# To disable a command, rename it to an empty string: rename-command FLUSHALL ""
rename-command FLUSHALL "FLUSHALL_DISABLED"
rename-command FLUSHDB "FLUSHDB_DISABLED"
rename-command KEYS "KEYS_DISABLED"
rename-command CONFIG "CONFIG_DISABLED"
rename-command DEBUG "DEBUG_DISABLED"
rename-command SHUTDOWN "SHUTDOWN_DISABLED"
rename-command SLAVEOF "SLAVEOF_DISABLED"
rename-command REPLICAOF "REPLICAOF_DISABLED"

# Bind Redis to specific network interfaces.
# In a Docker Compose setup, binding to 0.0.0.0 allows access from other services.
# For external access, ensure your firewall rules are strict.
bind 0.0.0.0

# Protected mode is enabled by default. It prevents clients that are not
# in the loopback interface from connecting to Redis if no 'bind' directive
# or 'requirepass' is configured. Keep it enabled.
protected-mode yes

# 4. Performance Optimizations
# Set the TCP backlog.
# The TCP backlog is the queue of pending connections.
# A larger backlog allows Redis to handle more concurrent connection attempts.
tcp-backlog 511

# TCP keepalive.
# If a client is idle for N seconds, send a TCP ACK packet to the client.
# This is useful to detect dead peers and to keep connections alive through NAT.
tcp-keepalive 300

# Run Redis as a daemon (background process).
# Set to 'no' for Docker containers, as the container's main process should be Redis.
daemonize no

# Supervised mode.
# Set to 'no' for Docker containers, as Docker handles process supervision.
supervised no

# Close the connection after a client is idle for N seconds (0 to disable).
# For production, it's often better to let the application manage connection pooling.
timeout 0

# Number of server cycles per second.
# A higher value means Redis will use more CPU but will be more responsive.
# Default is 10. For high-performance, consider 100.
hz 10

# Don't update LRU/LFU clocks on read operations.
# This can improve performance for read-heavy workloads, but might slightly
# reduce the accuracy of LRU/LFU eviction policies.
no-touch-on-read yes

# 5. Logging Configuration
# Specify the server verbosity level.
# This can be:
# debug (a lot of information, useful for development/testing)
# verbose (many useful info, but not a huge amount of useless noise)
# notice (moderately verbose, what you want in production)
# warning (only very important messages)
loglevel notice

# Specify the log file name.
# An empty string means logging to standard output (stdout), which is
# the recommended way to log when running Redis inside Docker.
logfile ""