"""
ROI & Business Value Analytics Engine
=====================================

This module provides the core analytics functions for calculating the tangible
business value generated by the AI Engine's automations. It translates raw
execution data into clear, high-level metrics like time saved and cost savings,
which are essential for demonstrating the platform's Return on Investment (ROI).

Key Features:
-   **Time Saved Calculation**: Aggregates the duration of all successful workflow
    executions to quantify the total hours of manual work saved.
-   **Cost Savings Estimation**: Converts the hours saved into a monetary value
    by applying a configurable average cost for a full-time equivalent (FTE)
    employee.
-   **Performance Metrics**: Calculates key performance indicators (KPIs) such as
    the total number of automations run and the overall success rate.
-   **User-Scoped Analytics**: All calculations are performed on a per-user basis,
    allowing for personalized ROI dashboards and reporting.
-   **Data-Driven**: Designed to operate on historical execution data, which would
    be queried from the production database in a real environment.
-   **Configurable and Extensible**: Key business logic, like the cost per hour,
    is defined in a configurable constant, making it easy to adjust.

This engine is crucial for bridging the gap between technical execution metrics
and the business-level value propositions that drive enterprise adoption.
"""

import logging
from datetime import datetime, timedelta
from typing import List, Dict, Any
import random

# Configure logging
logger = logging.getLogger(__name__)

# --- Configuration ---
# This constant can be moved to a central configuration file or environment variable.
# It represents the estimated fully-loaded cost of an employee per hour.
AVERAGE_FTE_COST_PER_HOUR = 50.0

# --- Mock Data Store ---
# In a real application, this function would query the `executions` table in the
# database, filtering by user_id and status.

def _get_execution_stats(user_id: int) -> List[Dict[str, Any]]:
    """
    Mock function to simulate fetching historical execution data for a user.

    Each record represents a completed workflow execution.

    Args:
        user_id: The ID of the user whose data is being fetched.

    Returns:
        A list of execution records.
    """
    logger.info(f"Fetching mock execution stats for user_id={user_id}")
    
    # Simulate a history of 150 executions for this user
    stats = []
    for i in range(150):
        # Simulate that 95% of workflows succeed
        is_success = random.random() < 0.95
        
        # Successful workflows have a duration, failed ones might not or it's irrelevant for ROI
        duration = random.uniform(30.0, 300.0) if is_success else 0
        
        stats.append({
            "workflow_id": f"wf_{random.randint(1, 5)}",
            "status": "completed" if is_success else "failed",
            "duration_seconds": duration,
            "completed_at": datetime.now() - timedelta(days=random.randint(0, 30))
        })
    return stats


# --- Core ROI Calculation Logic ---

def calculate_roi(user_id: int) -> Dict[str, Any]:
    """
    Calculates key ROI and performance metrics for a given user.

    It fetches the user's execution history and computes total hours saved,
    estimated cost savings, total automations run, and the success rate.

    Args:
        user_id: The ID of the user for whom to calculate ROI.

    Returns:
        A dictionary containing the calculated ROI metrics.
    """
    logger.info(f"Calculating ROI metrics for user_id={user_id}")
    
    # 1. Fetch the raw execution data
    execution_history = _get_execution_stats(user_id)
    
    if not execution_history:
        logger.warning(f"No execution history found for user_id={user_id}. Returning zeroed metrics.")
        return {
            "hours_saved": 0.0,
            "cost_saved": 0.0,
            "automations_run": 0,
            "success_rate": 100.0,
        }

    # 2. Process the data
    total_executions = len(execution_history)
    successful_executions = [exec for exec in execution_history if exec["status"] == "completed"]
    
    total_automations_run = len(successful_executions)
    
    # Sum the duration of only the successful runs to calculate time saved
    total_duration_seconds = sum(exec["duration_seconds"] for exec in successful_executions)
    
    # 3. Calculate the final metrics
    hours_saved = total_duration_seconds / 3600.0
    cost_saved = hours_saved * AVERAGE_FTE_COST_PER_HOUR
    success_rate = (total_automations_run / total_executions) * 100 if total_executions > 0 else 100.0
    
    # 4. Assemble the response
    roi_metrics = {
        "hours_saved": round(hours_saved, 2),
        "cost_saved": round(cost_saved, 2),
        "automations_run": total_automations_run,
        "success_rate": round(success_rate, 1),
    }
    
    logger.info(f"ROI calculation complete for user_id={user_id}: {roi_metrics}")
    return roi_metrics


# --- Example Usage ---
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    
    print("--- Running ROI Analytics Engine Demo ---")
    
    demo_user_id = 123
    roi_results = calculate_roi(demo_user_id)
    
    print(f"\nüìä ROI Report for User ID: {demo_user_id}")
    print("-----------------------------------------")
    print(f"  ‚úÖ Total Automations Run: {roi_results['automations_run']}")
    print(f"  üìà Success Rate: {roi_results['success_rate']}%")
    print(f"  ‚è∞ Total Hours Saved: {roi_results['hours_saved']} hours")
    print(f"  üí∞ Estimated Cost Saved: ${roi_results['cost_saved']:,.2f} (at ${AVERAGE_FTE_COST_PER_HOUR}/hr)")
    print("-----------------------------------------")
