"""
Workflow data-model
===================

This model supports **two representations** of a workflow:

1. Legacy **linear** representation – an ordered list of ``steps``.  
2. Modern **graph** representation – ``nodes`` and ``edges`` generated by the
   visual workflow editor.

The execution engine should prefer *nodes / edges* if present, otherwise fall
back to *steps* for backward-compatibility.

Additional sections:
• ``triggers``  – cron / event / manual trigger definitions.  
• ``approvals`` – human-in-the-loop approval requirements.  
• ``extra_metadata`` – free-form JSON for future extensions.
"""
from __future__ import annotations

from datetime import datetime
from typing import Optional, List, Dict

from sqlmodel import SQLModel, Field, JSON, Relationship

class Workflow(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str
    description: Optional[str] = None
    status: str = "draft"  # draft, active, archived
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    # Optional so programmatic tests / scripts can omit it.  In production this
    # should contain the username / service-account that created the workflow.
    created_by: Optional[str] = Field(default=None)

    # ------------------------------------------------------------------ #
    # Execution mode & preferences
    # ------------------------------------------------------------------ #

    # Determines where / how the workflow will run.
    # • attended    – runs on the end-user’s workstation with live feedback  
    # • unattended  – runs headless in the cloud / worker pool
    mode: str = Field(
        default="attended",
        description="Execution mode: 'attended' (desktop-assisted) or 'unattended' (cloud/headless).",
    )

    # Optional, arbitrary preferences for the executor / orchestrator
    # (e.g. queue name, priority, resource hints, parallelism).
    execution_prefs: Dict = Field(
        default_factory=dict,
        sa_type=JSON,
        description="Additional execution preferences (queue, priority, resources, etc.).",
    )

    # ------------------------------------------------------------------ #
    # Versioning / lineage
    # ------------------------------------------------------------------ #

    # Semantic version number – starts at 1 for the first saved workflow
    version: int = Field(default=1, description="Monotonically increasing version number.")

    # Self-referencing foreign-key for lineage / branching
    parent_workflow_id: Optional[int] = Field(
        default=None,
        foreign_key="workflow.id",
        description="If set, this workflow is a child version of `parent_workflow_id`.",
    )
    # Relationship helpers (lazy-loaded by SQLModel)
    parent: Optional["Workflow"] = Relationship(back_populates="children", sa_relationship_kwargs={"lazy": "selectin"})
    children: List["Workflow"] = Relationship(back_populates="parent", sa_relationship_kwargs={"lazy": "selectin"})

    # Optional human description of what changed from the parent
    version_notes: Optional[str] = Field(
        default=None,
        description="Optional notes describing the changes introduced in this version.",
    )

    # ------------------------------------------------------------------ #
    # Representations
    # ------------------------------------------------------------------ #

    # Legacy linear steps (kept for compatibility)
    # ------------------------------------------------------------------ #
    # Input-Process-Output (IPO) aware step definition
    # ------------------------------------------------------------------ #

    class StepIPO(SQLModel):
        """
        Explicit Input-Process-Output definition for a single workflow step.

        This nested model is *serialised as JSON* in the database to maintain
        backward-compatibility while providing clear semantics for each stage
        of a step.

        - ``input``    : description of required inputs (files, variables, etc.)
        - ``process`` : the action configuration (runner type, parameters, LLM prompt)
        - ``output``  : description / schema of the expected result
        - ``metadata``: free-form extras (confidence score, tags, etc.)
        """

        id: str
        name: str
        input: Dict = Field(default_factory=dict)
        process: Dict = Field(default_factory=dict)
        output: Dict = Field(default_factory=dict)
        metadata: Dict = Field(default_factory=dict)

    # Legacy linear steps now upgraded to explicit IPO structure but still
    # stored as JSON for seamless DB migration.
    steps: List[StepIPO] = Field(
        default_factory=list,
        sa_type=JSON,
        description="Ordered list of steps (Input-Process-Output aware).",
    )

    # Visual-editor graph representation
    nodes: List[Dict] = Field(
        default_factory=list,
        sa_type=JSON,
        description="Node definitions from the React Flow editor.",
    )
    edges: List[Dict] = Field(
        default_factory=list,
        sa_type=JSON,
        description="Edge definitions from the React Flow editor.",
    )
    triggers: List[Dict] = Field(default=[], sa_type=JSON)
    approvals: List[Dict] = Field(default=[], sa_type=JSON)
    extra_metadata: Dict = Field(default={}, sa_type=JSON) 

    # ------------------------------------------------------------------ #
    # Helper utilities
    # ------------------------------------------------------------------ #

    @classmethod
    def create_new_version(
        cls,
        original: "Workflow",
        *,
        updated_by: str,
        version_notes: str | None = None,
        **overrides,
    ) -> "Workflow":
        """
        Produce a **new persisted copy** of ``original`` with an incremented
        ``version`` number while preserving full history.

        Typical usage pattern in a service layer:

        ```python
        new_wf = Workflow.create_new_version(
            existing_wf,
            updated_by=current_user.username,
            version_notes="Added automatic PDF extraction step",
            steps=modified_steps,
        )
        session.add(new_wf); session.commit()
        ```
        """
        payload = original.model_dump(exclude={"id", "created_at", "updated_at"})
        payload.update(overrides)

        # Increment version & set lineage pointers
        payload["version"] = original.version + 1
        payload["parent_workflow_id"] = original.id
        payload["created_by"] = updated_by
        payload["version_notes"] = version_notes

        return cls(**payload)